$date
	Sat Feb  8 12:52:24 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module top_tb $end
$var reg 1 ! clk $end
$scope module dut $end
$var wire 1 ! clk $end
$var wire 32 " load_addr [31:0] $end
$var wire 1 # pc_enable $end
$var wire 1 $ pc_load $end
$var wire 32 % rs2_data [31:0] $end
$var wire 5 & rs2 [4:0] $end
$var wire 32 ' rs1_data [31:0] $end
$var wire 5 ( rs1 [4:0] $end
$var wire 1 ) reg_write $end
$var wire 32 * rd_data [31:0] $end
$var wire 5 + rd [4:0] $end
$var wire 32 , pc_out [31:0] $end
$var wire 1 - mem_write $end
$var wire 2 . mem_width [1:0] $end
$var wire 1 / mem_read $end
$var wire 1 0 is_lui $end
$var wire 1 1 is_jump $end
$var wire 1 2 is_jalr $end
$var wire 1 3 is_i_type $end
$var wire 1 4 is_branch $end
$var wire 32 5 instr [31:0] $end
$var wire 32 6 imm [31:0] $end
$var wire 3 7 branch_type [2:0] $end
$var wire 4 8 alu_ops [3:0] $end
$var reg 1 9 rst $end
$scope module alu_inst $end
$var wire 1 ! clk $end
$var wire 32 : imm_signed [31:0] $end
$var wire 32 ; rs1_signed [31:0] $end
$var wire 32 < rs2_signed [31:0] $end
$var wire 32 = rs2_data [31:0] $end
$var wire 32 > rs1_data [31:0] $end
$var wire 1 0 is_lui $end
$var wire 1 3 is_i_type $end
$var wire 32 ? imm [31:0] $end
$var wire 4 @ alu_ops [3:0] $end
$var reg 32 A rd_data [31:0] $end
$upscope $end
$scope module decoder_inst $end
$var wire 5 B rs2 [4:0] $end
$var wire 5 C rs1 [4:0] $end
$var wire 5 D rd [4:0] $end
$var wire 5 E opcode [4:0] $end
$var wire 32 F instr [31:0] $end
$var wire 7 G funct7 [6:0] $end
$var wire 3 H funct3 [2:0] $end
$var parameter 5 I BRANCH $end
$var parameter 5 J I_TYPE $end
$var parameter 5 K JAL $end
$var parameter 5 L JALR $end
$var parameter 5 M LOAD $end
$var parameter 5 N LUI $end
$var parameter 5 O R_TYPE $end
$var parameter 5 P STORE $end
$var reg 4 Q alu_ops [3:0] $end
$var reg 3 R branch_type [2:0] $end
$var reg 32 S imm [31:0] $end
$var reg 1 4 is_branch $end
$var reg 1 3 is_i_type $end
$var reg 1 2 is_jalr $end
$var reg 1 1 is_jump $end
$var reg 1 0 is_lui $end
$var reg 1 / mem_read $end
$var reg 2 T mem_width [1:0] $end
$var reg 1 - mem_write $end
$var reg 1 ) reg_write $end
$var reg 1 U rs1_used $end
$var reg 1 V rs2_used $end
$upscope $end
$scope module instr_mem $end
$var wire 32 W addr [31:0] $end
$var reg 1 X continue_reading $end
$var reg 32 Y instr_out [31:0] $end
$var integer 32 Z file [31:0] $end
$var integer 32 [ i [31:0] $end
$var integer 32 \ status [31:0] $end
$upscope $end
$scope module pc_inst $end
$var wire 32 ] addr [31:0] $end
$var wire 1 ! clk $end
$var wire 1 # enable $end
$var wire 1 $ load $end
$var wire 1 9 rst $end
$var reg 32 ^ pc [31:0] $end
$upscope $end
$scope module regfile_inst $end
$var wire 1 ! clk $end
$var wire 5 _ rd_addr [4:0] $end
$var wire 32 ` rd_data [31:0] $end
$var wire 5 a rs1_addr [4:0] $end
$var wire 5 b rs2_addr [4:0] $end
$var wire 1 c rst_n $end
$var wire 1 ) we $end
$var wire 32 d rs2_data [31:0] $end
$var wire 32 e rs1_data [31:0] $end
$scope begin $unm_blk_31 $end
$var integer 32 f i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b1000 P
b1100 O
b1101 N
b0 M
b11001 L
b11011 K
b100 J
b11000 I
$end
#0
$dumpvars
bx f
b0 e
b0 d
zc
b0 b
b0 a
b0 `
b101 _
b0 ^
b0 ]
b11111111111111111111111111111111 \
b101 [
b10000000000000000000000000000011 Z
b1010110111 Y
0X
b0 W
xV
xU
bx T
b0 S
bx R
bx Q
b0 H
b0 G
b1010110111 F
b1101 E
b101 D
b0 C
b0 B
b0 A
bx @
b0 ?
b0 >
b0 =
b0 <
b0 ;
b0 :
19
bx 8
bx 7
b0 6
b1010110111 5
x4
03
x2
x1
10
x/
bx .
x-
b0 ,
b101 +
b0 *
1)
b0 (
b0 '
b0 &
b0 %
0$
1#
b0 "
0!
$end
#1
1!
#2
0!
#3
1!
#4
0!
#5
1!
#6
0!
#7
1!
#8
0!
#9
1!
#10
0!
09
#11
bx <
bx %
bx =
bx d
13
b0 8
b0 @
b0 Q
b110 *
b110 A
b110 `
b110 &
b110 B
b110 b
b101 (
b101 C
b101 a
b100 E
b110 :
b110 6
b110 ?
b110 S
00
b11000101000001010010011 5
b11000101000001010010011 F
b11000101000001010010011 Y
b100 ,
b100 W
b100 ^
1!
#12
0!
#13
b0 <
b0 %
b0 =
b0 d
b0 :
b0 6
b0 ?
b0 S
10
b111 +
b111 D
b111 _
b0 &
b0 B
b0 b
b0 (
b0 C
b0 a
b1101 E
03
b0 *
b0 A
b0 `
b1110110111 5
b1110110111 F
b1110110111 Y
b0 ;
b0 '
b0 >
b0 e
b1000 ,
b1000 W
b1000 ^
1!
#14
0!
#15
bx <
bx %
bx =
bx d
13
b10 *
b10 A
b10 `
b10 &
b10 B
b10 b
b111 (
b111 C
b111 a
b100 E
b10 :
b10 6
b10 ?
b10 S
00
b1000111000001110010011 5
b1000111000001110010011 F
b1000111000001110010011 Y
b1100 ,
b1100 W
b1100 ^
1!
#16
0!
#17
b110 <
b110 %
b110 =
b110 d
1V
1U
b101 8
b101 @
b101 Q
b101 &
b101 B
b101 b
b1 H
b1100 E
03
b10000000 *
b10000000 A
b10000000 `
b10100111001001110110011 5
b10100111001001110110011 F
b10100111001001110110011 Y
b10 ;
b10 '
b10 >
b10 e
b10000 ,
b10000 W
b10000 ^
1!
#18
0!
#19
b0 <
b0 %
b0 =
b0 d
b0 +
b0 D
b0 _
b0 &
b0 B
b0 b
b0 (
b0 C
b0 a
b0 H
b0 E
b0 *
b0 A
b0 `
b0 5
b0 F
b0 Y
b0 ;
b0 '
b0 >
b0 e
b10100 ,
b10100 W
b10100 ^
1!
#20
0!
#21
b11000 ,
b11000 W
b11000 ^
1!
#22
0!
#23
b11100 ,
b11100 W
b11100 ^
1!
#24
0!
#25
b100000 ,
b100000 W
b100000 ^
1!
#26
0!
#27
b100100 ,
b100100 W
b100100 ^
1!
#28
0!
#29
b101000 ,
b101000 W
b101000 ^
1!
#30
0!
#31
b101100 ,
b101100 W
b101100 ^
1!
#32
0!
#33
b110000 ,
b110000 W
b110000 ^
1!
#34
0!
#35
b110100 ,
b110100 W
b110100 ^
1!
#36
0!
#37
b111000 ,
b111000 W
b111000 ^
1!
#38
0!
#39
b111100 ,
b111100 W
b111100 ^
1!
#40
0!
#41
b1000000 ,
b1000000 W
b1000000 ^
1!
#42
0!
#43
b1000100 ,
b1000100 W
b1000100 ^
1!
#44
0!
#45
b1001000 ,
b1001000 W
b1001000 ^
1!
#46
0!
#47
b1001100 ,
b1001100 W
b1001100 ^
1!
#48
0!
#49
b1010000 ,
b1010000 W
b1010000 ^
1!
#50
0!
#51
b1010100 ,
b1010100 W
b1010100 ^
1!
#52
0!
#53
b1011000 ,
b1011000 W
b1011000 ^
1!
#54
0!
#55
b1011100 ,
b1011100 W
b1011100 ^
1!
#56
0!
#57
b1100000 ,
b1100000 W
b1100000 ^
1!
#58
0!
#59
b1100100 ,
b1100100 W
b1100100 ^
1!
#60
0!
#61
b1101000 ,
b1101000 W
b1101000 ^
1!
#62
0!
#63
b1101100 ,
b1101100 W
b1101100 ^
1!
#64
0!
#65
b1110000 ,
b1110000 W
b1110000 ^
1!
